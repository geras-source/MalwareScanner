using MalwareScanner.File;
using MalwareScanner.Report;
using System;
using System.Collections.Concurrent;
using System.Diagnostics;
using System.IO;
using System.Threading.Tasks;

namespace MalwareScanner.Scanner
{
    class ScannerServices : IScannerServices
    {
        private IReportServices _reportServices { get; }
        private readonly object _sync = new object();

        public ScannerServices(IReportServices reportServices)
        {
            _reportServices = reportServices;
        }
        /// <summary>
        /// Коллекция malware'ов
        /// </summary>
        private readonly Malwares[] malwares = new Malwares[]
        {
            new Malwares()
            {
                Name = "JS",
                Malware = "<script>evil_script()</script>",
                Extension = ".js"
            },
            new Malwares()
            {
                Name = "rm -rf",
                Malware = @"rm -rf %userprofile%\Documents",
                Extension = "*"
            },
            new Malwares()
            {
                Name = "Rundll32",
                Malware = "Rundll32 sus.dll SusEntry",
                Extension = "*"
            }
        };
        /// <summary>
        /// Реализация метода по старту сканирования
        /// Сканирование производится параллельно, максимальное кол-во операций равно кол-ву потоков процессора
        /// </summary>
        /// <param name="listOfFiles">Файлы для сканирования</param>
        public void StartScan(ConcurrentBag<Files> listOfFiles)
        {
            Stopwatch stopWatch = new Stopwatch();
            stopWatch.Start();
            
            var countOfJsMalware = 0;           // TODO: такой подход является все же некорректным в связи с тем,
            var countOfRmMalware = 0;           // что количество malware'ов может увеличивать => 
            var countOfRundll32Malware = 0;     // приведет к большому количеству однотипных переменных,
            var errorInReadAFile = 0;           // можно было бы также сделать еще одну сущность(или структуру)
            
            Parallel.ForEach(listOfFiles, new ParallelOptions { MaxDegreeOfParallelism = Environment.ProcessorCount }, file =>
            {
                if (file.IsRead == true)
                {
                    foreach (var malware in malwares)
                    {
                        if (Path.GetExtension(file.PathTofile) != malware.Extension && (malware.Extension != "*"))
                            continue;
                        if (file.TextFromFile.Contains(malware.Malware))
                        {
                            lock (_sync)
                            {
                                switch (malware.Name)
                                {
                                    case "JS":
                                        countOfJsMalware++;         // также я неуверен, что использование параллельной проверки файлов ускоряет приложение,
                                        break;                      // ведь самое загруженное место находится в FileServices, а именно - считываение текста из файлов,
                                    case "rm -rf":                  // но я не смог нормально проверить эту гипотезу, т.к. не нашел большого количесвта файлов для теста
                                        countOfRmMalware++;
                                        break;
                                    case "Rundll32":
                                        countOfRundll32Malware++;
                                        break;
                                }
                            }
                        }
                    }
                }
                else
                {
                    errorInReadAFile++;
                }
            });
            stopWatch.Stop();
            var entity = new ReportModel()
            {
                ProcessedFiles = listOfFiles.Count,
                JsDetecting = countOfJsMalware,
                RmDetecting = countOfRmMalware,
                Rundll32Detecting = countOfRundll32Malware,
                Errors = errorInReadAFile,
                ExectionTime = stopWatch.Elapsed
            };
            _reportServices.CreateAReport(entity);
        }
    }
}